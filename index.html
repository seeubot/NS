<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamVault - Your Media Library</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom styles for a cleaner look -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Centering the main content container */
        .main-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            padding: 1rem;
        }

        .search-input-container {
            width: 100%;
            max-width: 7xl;
            margin-bottom: 3rem;
            display: flex;
            justify-content: center;
        }

        /* Custom scrollbar for the episode selector */
        .episode-selector::-webkit-scrollbar {
            width: 8px;
        }
        .episode-selector::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .episode-selector::-webkit-scrollbar-thumb {
            background-color: #4ecdc4;
            border-radius: 20px;
            border: 2px solid #1f2937;
        }
        .episode-selector {
            scrollbar-width: thin;
            scrollbar-color: #4ecdc4 #1f2937;
        }

        .media-card {
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .media-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .search-input:focus {
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.02);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.3);
        }

        .video-player-modal {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }

        .player-container {
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .close-player:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .episode-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
        }
        
        /* Styles for the full-screen video player UI */
        .video-ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            background: #000;
            z-index: 50;
        }
        .video-player-wrapper {
            flex-grow: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            flex-direction: column;
        }
        
        /* This is the key for Android TV focus state */
        .focusable:focus,
        .video-control-btn:focus,
        .episode-list-item:focus {
            outline: 2px solid #4ecdc4;
            outline-offset: 4px; /* Increased offset for better visibility */
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
            transform: scale(1.05);
        }

        /* Custom video controls styling */
        .custom-video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 100; /* Ensure controls are above other overlays */
        }

        .show-controls .custom-video-controls {
            opacity: 1;
        }

        .seek-bar-container {
            flex-grow: 1;
            position: relative;
        }

        .seek-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }

        .seek-bar-filled {
            height: 100%;
            background-color: #4ecdc4;
            border-radius: 4px;
            width: 0%;
        }

        /* Video info overlay on pause */
        .video-info-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Initially hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            text-align: center;
            z-index: 20;
            padding: 1rem;
        }

        .video-info-overlay.visible {
            display: flex;
        }
        
        /* Error Dialog styles */
        .error-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            z-index: 200;
            display: none;
            text-align: center;
        }
        
        .error-dialog.visible {
            display: block;
        }

        /* Episode list overlay within the player */
        .episode-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 150;
            display: none; /* Hidden by default */
            flex-direction: column;
            padding: 2rem;
        }
        .episode-overlay.visible {
            display: flex;
        }
        
        /* Loading spinner animation */
        .loading-spinner {
            border: 6px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 6px solid #4ecdc4;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            position: absolute;
            z-index: 30;
            top: 50%;
            left: 50%;
            margin-top: -30px;
            margin-left: -30px;
            display: none; /* Initially hidden */
        }
        .loading-spinner.visible {
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1024px) {
            .video-ui-container {
                flex-direction: column;
            }
            .video-player-wrapper {
                width: 100%;
                height: 50%; /* Adjust as needed */
            }
            .video-player-sidebar {
                width: 100%;
                height: 50%;
            }
        }

        /* New CSS for video object-fit */
        .video-fit-fill {
            object-fit: fill;
        }
        .video-fit-contain {
            object-fit: contain;
        }
        .video-fit-cover {
            object-fit: cover;
        }
        .video-fit-auto {
            object-fit: auto;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen p-4">

    <!-- Search Bar Section - Always visible, now centered vertically and horizontally -->
    <div id="search-container" class="main-container">
        <input type="text" id="search-input" data-focusable="true" placeholder="Search for movies or series..." class="focusable w-full max-w-xl p-4 text-xl rounded-full bg-gray-800 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent">
    </div>

    <!-- Main Content Area - Initially Hidden -->
    <div id="content-area" class="hidden w-full max-w-7xl mx-auto flex-grow">
        <!-- Header Section - Initially Hidden -->
        <header id="header-container" class="hidden flex flex-col md:flex-row items-center justify-between pb-8 border-b border-gray-700 mb-8 w-full">
            <h1 class="text-4xl font-extrabold text-white">Media Manager</h1>
            <div id="stats-container" class="flex items-center space-x-4 mt-4 md:mt-0">
                <!-- Stats will be dynamically injected here by JavaScript -->
            </div>
        </header>

        <!-- Navigation Tabs -->
        <div class="flex space-x-4 mb-8 border-b border-gray-700">
            <button id="movies-tab" data-focusable="true" class="focusable tab-button py-2 px-4 text-lg font-medium text-white border-b-2 border-teal-400">Movies</button>
            <button id="series-tab" data-focusable="true" class="focusable tab-button py-2 px-4 text-lg font-medium text-gray-400 hover:text-gray-200">Series</button>
        </div>

        <!-- Loading and Error messages -->
        <div id="loading-message" class="flex items-center justify-center py-12">
            <p class="text-xl font-medium">Loading data...</p>
        </div>
        <div id="error-message" class="hidden text-center text-red-400 p-4 text-xl">
            <p>Failed to fetch data from the API. Please check if the backend is running.</p>
        </div>

        <!-- Media content will be rendered here by JavaScript -->
        <div id="media-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div>
    </div>

    <!-- Video Player Modal -->
    <div id="video-player-modal" class="hidden video-player-modal fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="player-container relative w-full h-full lg:h-3/4 flex flex-col lg:flex-row bg-gray-800 rounded-xl overflow-hidden">
            <!-- Player Wrapper -->
            <div class="video-player-wrapper flex flex-col justify-center items-center w-full lg:w-3/4 relative">
                <video id="video-player" class="w-full h-full object-contain" controls>
                    Your browser does not support the video tag.
                </video>
                <div class="custom-video-controls hidden lg:flex items-center justify-between w-full p-4 absolute bottom-0">
                    <button id="play-pause-btn" class="video-control-btn text-4xl p-2 rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-opacity-50">▶</button>
                    <div id="seek-bar-container" class="seek-bar-container mx-4">
                        <div id="seek-bar" class="seek-bar w-full h-2 bg-gray-600 rounded-full cursor-pointer">
                            <div id="seek-bar-filled" class="seek-bar-filled h-full bg-teal-400 rounded-full"></div>
                        </div>
                    </div>
                    <div id="video-time" class="text-sm w-24 text-right">00:00 / 00:00</div>
                    <button id="fullscreen-btn" class="video-control-btn text-2xl p-2 rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-opacity-50">⛶</button>
                </div>
                <div id="video-loading-spinner" class="loading-spinner"></div>
                <div id="video-info-overlay" class="video-info-overlay visible">
                    <img id="video-info-thumbnail" src="" alt="Thumbnail" class="w-32 h-48 rounded-lg mb-4">
                    <h2 id="video-info-title" class="text-3xl font-bold mb-2"></h2>
                    <p id="video-info-subtitle" class="text-xl text-gray-400"></p>
                    <button id="close-player-btn" class="close-player absolute top-4 right-4 text-gray-400 hover:text-white text-4xl transform transition-transform duration-300 ease-in-out focusable" data-focusable="true">×</button>
                </div>
                 <!-- Error Dialog -->
                <div id="video-error-dialog" class="error-dialog hidden">
                    <p id="video-error-message" class="text-lg font-semibold mb-4"></p>
                    <button id="video-error-ok-btn" class="focusable bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-full transition-all duration-300">OK</button>
                </div>
            </div>

            <!-- Sidebar for Episodes/Seasons -->
            <div id="video-player-sidebar" class="hidden lg:block w-full lg:w-1/4 p-4 border-l border-gray-700 overflow-y-auto episode-selector">
                <h3 class="text-2xl font-semibold mb-4">Episodes</h3>
                <div id="episode-list">
                    <!-- Episode buttons will be injected here -->
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE_URL = 'https://future-ester-seeutech-645c6129.koyeb.app/api';

        const contentArea = document.getElementById('content-area');
        const headerContainer = document.getElementById('header-container');
        const searchInput = document.getElementById('search-input');
        const loadingMessage = document.getElementById('loading-message');
        const errorMessage = document.getElementById('error-message');
        const mediaGrid = document.getElementById('media-grid');
        const moviesTab = document.getElementById('movies-tab');
        const seriesTab = document.getElementById('series-tab');
        const statsContainer = document.getElementById('stats-container');

        const videoPlayerModal = document.getElementById('video-player-modal');
        const videoPlayer = document.getElementById('video-player');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const seekBar = document.getElementById('seek-bar');
        const seekBarFilled = document.getElementById('seek-bar-filled');
        const videoTime = document.getElementById('video-time');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const closePlayerBtn = document.getElementById('close-player-btn');
        const episodeList = document.getElementById('episode-list');
        const videoInfoOverlay = document.getElementById('video-info-overlay');
        const videoInfoThumbnail = document.getElementById('video-info-thumbnail');
        const videoInfoTitle = document.getElementById('video-info-title');
        const videoInfoSubtitle = document.getElementById('video-info-subtitle');
        const videoLoadingSpinner = document.getElementById('video-loading-spinner');
        const videoErrorDialog = document.getElementById('video-error-dialog');
        const videoErrorMessage = document.getElementById('video-error-message');
        const videoErrorOkBtn = document.getElementById('video-error-ok-btn');
        const episodeOverlay = document.getElementById('episode-overlay');
        const videoPlayerSidebar = document.getElementById('video-player-sidebar');

        let allMovies = [];
        let allSeries = [];
        let currentMediaType = 'movies';
        let currentMedia = null;
        let activeElementIndex = 0;
        let focusableElements = [];

        /**
         * Fetches media data from the API with exponential backoff.
         * @param {string} endpoint - The API endpoint to fetch.
         * @param {number} retries - Number of retries.
         * @param {number} delay - Initial delay in ms.
         */
        async function fetchDataWithRetry(endpoint, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`${API_BASE_URL}${endpoint}`);
                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed for ${endpoint}:`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        throw error;
                    }
                }
            }
        }

        /**
         * Fetches all data and updates the UI.
         */
        async function fetchAllData() {
            loadingMessage.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            try {
                const [movies, series, stats] = await Promise.all([
                    fetchDataWithRetry('/movies'),
                    fetchDataWithRetry('/series'),
                    fetchDataWithRetry('/stats')
                ]);
                allMovies = movies;
                allSeries = series;
                updateStats(stats);
                updateMediaGrid();
                contentArea.classList.remove('hidden');
                headerContainer.classList.remove('hidden');
                loadingMessage.classList.add('hidden');
                // Set initial focus
                setTimeout(setInitialFocus, 100);
            } catch (error) {
                console.error("Failed to load all data:", error);
                loadingMessage.classList.add('hidden');
                errorMessage.classList.remove('hidden');
            }
        }
        
        /**
         * Shows the error dialog with a specific message.
         * @param {string} message - The message to display.
         */
        function showVideoError(message) {
            videoErrorMessage.textContent = message;
            videoErrorDialog.classList.remove('hidden');
            videoErrorDialog.classList.add('visible');
            videoErrorOkBtn.focus();
        }

        /**
         * Hides the video error dialog.
         */
        function hideVideoError() {
            videoErrorDialog.classList.remove('visible');
            videoErrorDialog.classList.add('hidden');
        }

        /**
         * Updates the statistics in the header.
         * @param {object} stats - The statistics object from the API.
         */
        function updateStats(stats) {
            statsContainer.innerHTML = `
                <span class="text-sm font-semibold text-gray-400">Total Movies: <span class="text-teal-400">${stats.movieCount}</span></span>
                <span class="text-sm font-semibold text-gray-400">Total Series: <span class="text-teal-400">${stats.seriesCount}</span></span>
            `;
        }

        /**
         * Renders the media grid based on the current media type and search query.
         * @param {string} query - The search query.
         */
        function updateMediaGrid(query = '') {
            const media = currentMediaType === 'movies' ? allMovies : allSeries;
            const filteredMedia = media.filter(item =>
                item.name.toLowerCase().includes(query.toLowerCase())
            );

            mediaGrid.innerHTML = '';
            filteredMedia.forEach(item => {
                const card = document.createElement('div');
                card.className = 'media-card relative overflow-hidden rounded-xl cursor-pointer shadow-lg transform transition-all duration-300 focusable group';
                card.tabIndex = 0; // Make card focusable
                card.setAttribute('data-focusable', 'true');
                card.setAttribute('data-id', item._id);
                card.innerHTML = `
                    <img src="${item.thumbnail || 'https://placehold.co/400x600/1f2937/d1d5db?text=No+Image'}" alt="${item.name}" class="w-full h-auto object-cover rounded-xl transition-transform duration-300 group-focus:scale-110 group-hover:scale-110">
                    <div class="absolute inset-0 bg-gradient-to-t from-black to-transparent opacity-70"></div>
                    <div class="absolute bottom-0 left-0 p-4 w-full">
                        <h3 class="text-lg font-semibold text-white truncate">${item.name}</h3>
                    </div>
                `;
                card.addEventListener('click', () => openVideoPlayer(item));
                mediaGrid.appendChild(card);
            });
            updateFocusableElements();
        }

        /**
         * Opens the video player modal for a given media item.
         * @param {object} media - The media item to play.
         */
        function openVideoPlayer(media) {
            currentMedia = media;
            videoPlayerModal.classList.remove('hidden');
            videoInfoOverlay.classList.add('visible');
            videoInfoThumbnail.src = media.thumbnail || 'https://placehold.co/400x600/1f2937/d1d5db?text=No+Image';
            videoInfoTitle.textContent = media.name;
            playPauseBtn.textContent = '▶';
            
            // Set initial video source for movies
            if (currentMediaType === 'movies') {
                videoPlayer.src = media.streamingUrl;
                videoInfoSubtitle.textContent = 'Movie';
                videoPlayerSidebar.classList.add('hidden');
            } else { // Handle series
                videoPlayerSidebar.classList.remove('hidden');
                // Find the first episode of the first season and set it
                if (media.seasons && media.seasons.length > 0) {
                    const firstSeason = media.seasons[0];
                    if (firstSeason.episodes && firstSeason.episodes.length > 0) {
                        const firstEpisode = firstSeason.episodes[0];
                        videoPlayer.src = firstEpisode.streamingUrl;
                        videoInfoSubtitle.textContent = `S${firstSeason.seasonNumber} E${firstEpisode.episodeNumber}: ${firstEpisode.title}`;
                        renderEpisodeList(media);
                    } else {
                        showVideoError("No episodes found for this series.");
                    }
                } else {
                    showVideoError("No seasons or episodes found for this series.");
                }
            }
            videoPlayer.load();
            videoPlayerModal.focus(); // Focus on the modal
            updateFocusableElements();
        }

        /**
         * Renders the episode list for a series.
         * @param {object} series - The series item.
         */
        function renderEpisodeList(series) {
            episodeList.innerHTML = '';
            series.seasons.forEach(season => {
                const seasonTitle = document.createElement('h4');
                seasonTitle.className = 'text-lg font-semibold text-gray-300 mt-4 mb-2';
                seasonTitle.textContent = `Season ${season.seasonNumber}`;
                episodeList.appendChild(seasonTitle);
                
                season.episodes.forEach(episode => {
                    const episodeBtn = document.createElement('button');
                    episodeBtn.className = 'episode-list-item w-full flex items-center justify-start p-2 rounded-lg my-1 transition-colors duration-200 focusable';
                    episodeBtn.tabIndex = 0;
                    episodeBtn.setAttribute('data-focusable', 'true');
                    episodeBtn.setAttribute('data-url', episode.streamingUrl);
                    episodeBtn.setAttribute('data-episode-title', `S${season.seasonNumber} E${episode.episodeNumber}: ${episode.title}`);
                    episodeBtn.innerHTML = `
                        <span class="text-sm font-medium">E${episode.episodeNumber}: ${episode.title}</span>
                    `;
                    episodeBtn.addEventListener('click', () => {
                        playEpisode(episode.streamingUrl, `S${season.seasonNumber} E${episode.episodeNumber}: ${episode.title}`);
                    });
                    episodeList.appendChild(episodeBtn);
                });
            });
            updateFocusableElements();
        }

        /**
         * Plays a specific episode.
         * @param {string} url - The streaming URL.
         * @param {string} title - The title of the episode.
         */
        function playEpisode(url, title) {
            videoPlayer.src = url;
            videoInfoSubtitle.textContent = title;
            videoPlayer.load();
            videoPlayer.play();
            videoInfoOverlay.classList.remove('visible');
        }

        /**
         * Toggles play/pause state of the video.
         */
        function togglePlayPause() {
            if (videoPlayer.paused || videoPlayer.ended) {
                videoPlayer.play();
                videoInfoOverlay.classList.remove('visible');
            } else {
                videoPlayer.pause();
            }
        }

        /**
         * Formats time in seconds to HH:MM:SS.
         * @param {number} seconds - The time in seconds.
         * @returns {string} The formatted time string.
         */
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const pad = (num) => String(num).padStart(2, '0');
            return `${pad(h > 0 ? h : '')}${h > 0 ? ':' : ''}${pad(m)}:${pad(s)}`;
        }

        /**
         * Updates the list of focusable elements on the page.
         */
        function updateFocusableElements() {
            focusableElements = Array.from(document.querySelectorAll('[data-focusable="true"]'));
        }

        /**
         * Sets initial focus on the search input.
         */
        function setInitialFocus() {
            updateFocusableElements();
            if (focusableElements.length > 0) {
                activeElementIndex = 0;
                focusableElements[activeElementIndex].focus();
            }
        }

        /**
         * Finds the next focusable element in a given direction.
         * This is the core logic for D-pad navigation.
         * @param {string} direction - 'up', 'down', 'left', 'right'.
         */
        function findNextFocus(direction) {
            const currentElement = focusableElements[activeElementIndex];
            if (!currentElement) return;

            const currentRect = currentElement.getBoundingClientRect();
            let nextElement = null;
            let minDistance = Infinity;

            focusableElements.forEach((el, index) => {
                if (el === currentElement) return;

                const elRect = el.getBoundingClientRect();
                let distance = Infinity;

                if (direction === 'down' && elRect.top > currentRect.bottom) {
                    distance = Math.sqrt(Math.pow(elRect.left - currentRect.left, 2) + Math.pow(elRect.top - currentRect.top, 2));
                } else if (direction === 'up' && elRect.bottom < currentRect.top) {
                    distance = Math.sqrt(Math.pow(elRect.left - currentRect.left, 2) + Math.pow(elRect.bottom - currentRect.bottom, 2));
                } else if (direction === 'right' && elRect.left > currentRect.right) {
                    distance = Math.sqrt(Math.pow(elRect.top - currentRect.top, 2) + Math.pow(elRect.left - currentRect.left, 2));
                } else if (direction === 'left' && elRect.right < currentRect.left) {
                    distance = Math.sqrt(Math.pow(elRect.top - currentRect.top, 2) + Math.pow(elRect.right - currentRect.right, 2));
                }

                if (distance < minDistance) {
                    minDistance = distance;
                    nextElement = el;
                    activeElementIndex = index;
                }
            });

            if (nextElement) {
                nextElement.focus();
            }
        }

        // --- Event Listeners ---

        document.addEventListener('DOMContentLoaded', fetchAllData);

        // Handle navigation with arrow keys for Android TV webview
        document.addEventListener('keydown', (e) => {
            if (videoPlayerModal.classList.contains('hidden')) {
                // Main grid navigation
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        findNextFocus('down');
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        findNextFocus('up');
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        findNextFocus('left');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        findNextFocus('right');
                        break;
                    case 'Enter':
                        e.preventDefault();
                        const activeEl = document.activeElement;
                        if (activeEl && activeEl.getAttribute('data-focusable') === 'true') {
                            activeEl.click();
                        }
                        break;
                    case 'Backspace':
                    case 'Escape':
                        e.preventDefault();
                        // Handle back action (e.g., clear search, go back to main screen)
                        if (searchInput.value !== '') {
                             searchInput.value = '';
                             updateMediaGrid();
                        }
                        break;
                }
            } else {
                // Player modal navigation
                switch (e.key) {
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        // Allow navigation within player controls or episode list
                        break;
                    case 'Enter':
                        // Play/Pause on Enter press
                        togglePlayPause();
                        break;
                    case 'Escape':
                    case 'Backspace':
                        // Close player on back/escape
                        videoPlayerModal.classList.add('hidden');
                        videoPlayer.pause();
                        videoPlayer.currentTime = 0;
                        break;
                }
            }
        });

        // Tab and Enter key listeners for accessibility and TV remote support
        document.addEventListener('keydown', (e) => {
            // Re-map the Enter key to click a focused element
            if (e.key === 'Enter') {
                const activeEl = document.activeElement;
                if (activeEl && activeEl.getAttribute('data-focusable') === 'true') {
                    e.preventDefault();
                    activeEl.click();
                }
            }
        });

        // Search functionality
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                updateMediaGrid(searchInput.value);
            }, 300);
        });

        // Tab switching
        moviesTab.addEventListener('click', () => {
            currentMediaType = 'movies';
            moviesTab.classList.add('border-teal-400', 'text-white');
            moviesTab.classList.remove('text-gray-400');
            seriesTab.classList.remove('border-teal-400', 'text-white');
            seriesTab.classList.add('text-gray-400');
            updateMediaGrid(searchInput.value);
        });

        seriesTab.addEventListener('click', () => {
            currentMediaType = 'series';
            seriesTab.classList.add('border-teal-400', 'text-white');
            seriesTab.classList.remove('text-gray-400');
            moviesTab.classList.remove('border-teal-400', 'text-white');
            moviesTab.classList.add('text-gray-400');
            updateMediaGrid(searchInput.value);
        });
        
        // Video player controls
        closePlayerBtn.addEventListener('click', () => {
            videoPlayerModal.classList.add('hidden');
            videoPlayer.pause();
            videoPlayer.currentTime = 0;
        });

        playPauseBtn.addEventListener('click', togglePlayPause);

        videoPlayer.addEventListener('play', () => {
            playPauseBtn.textContent = '⏸';
            videoInfoOverlay.classList.remove('visible');
        });

        videoPlayer.addEventListener('pause', () => {
            playPauseBtn.textContent = '▶';
            // Show the info overlay on pause, but only if the video is not at the end
            if (videoPlayer.currentTime < videoPlayer.duration && !videoErrorDialog.classList.contains('visible')) {
                videoInfoOverlay.classList.add('visible');
                // Update the overlay with current media info
                if (currentMedia) {
                    videoInfoThumbnail.src = currentMedia.thumbnail || 'https://placehold.co/400x600/1f2937/d1d5db?text=No+Image';
                    videoInfoTitle.textContent = currentMedia.name || currentMedia.title;
                }
            }
        });

        videoPlayer.addEventListener('waiting', () => {
            videoLoadingSpinner.classList.add('visible');
        });

        videoPlayer.addEventListener('playing', () => {
            videoLoadingSpinner.classList.remove('visible');
        });
        
        videoPlayer.addEventListener('stalled', () => {
            videoLoadingSpinner.classList.add('visible');
        });

        videoPlayer.addEventListener('timeupdate', () => {
            const currentTime = videoPlayer.currentTime;
            const duration = videoPlayer.duration;
            const progress = (currentTime / duration) * 100;
            seekBarFilled.style.width = `${progress}%`;
            videoTime.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
        });
        
        videoPlayer.addEventListener('error', (e) => {
            console.error('Video playback error:', e);
            let message = "An unknown error occurred during video playback.";
            if (videoPlayer.error) {
                switch (videoPlayer.error.code) {
                    case videoPlayer.error.MEDIA_ERR_ABORTED:
                        message = "The video playback was aborted.";
                        break;
                    case videoPlayer.error.MEDIA_ERR_NETWORK:
                        message = "A network error caused the video to fail.";
                        break;
                    case videoPlayer.error.MEDIA_ERR_DECODE:
                        message = "The video format is not supported.";
                        break;
                    case videoPlayer.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        message = "The video URL is not supported or cannot be found.";
                        break;
                    default:
                        message = `Video playback error: Code ${videoPlayer.error.code}`;
                        break;
                }
            }
            showVideoError(message);
            videoLoadingSpinner.classList.remove('visible');
        });

        seekBar.addEventListener('click', (e) => {
            const rect = seekBar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            videoPlayer.currentTime = videoPlayer.duration * percent;
        });

        videoErrorOkBtn.addEventListener('click', () => {
            hideVideoError();
            videoPlayer.pause();
            videoPlayer.currentTime = 0;
            // Focus on close player button after error dismissal
            closePlayerBtn.focus();
        });

        fullscreenBtn.addEventListener('click', () => {
            if (videoPlayer.requestFullscreen) {
                videoPlayer.requestFullscreen();
            } else if (videoPlayer.webkitRequestFullscreen) { /* Safari */
                videoPlayer.webkitRequestFullscreen();
            } else if (videoPlayer.msRequestFullscreen) { /* IE11 */
                videoPlayer.msRequestFullscreen();
            }
        });
    </script>
</body>
</html>
